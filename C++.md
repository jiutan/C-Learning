# C++基础知识
## 一、对象 与 类（什么是对象，对象能干什么）
### 1. 对象
1. 广义定义：在**内存中 分配地址**的变量。
### 2. 类
一个类 既要 **规定初始化其对象的方法**，又要 **定义对象上所能执行的操作**。
既能定义 **通过函数名调用的操作**，又能定义 <<、>>、+等各种运算符在该类对象上的**新含义**

## 二、模板：C++语言 既有类模板 又有函数模板
1. 定义：编译器生成类或函数 编写的一份说明。
2. 实例化：编译器根据模板创建类或函数的过程
3. 注意：当使用模板时，需要指出编译器应把 类或函数 **实例化成何种类型**
### 1.类模板（第16章）
1. vector是类模板
2. 使用时，需提供 **额外信息**来指定模板 到底实例化成什么样的类
3. 提供额外信息的方法：在**模板名字后面跟一对尖括号，在括号内放上信息**
### 2.函数模板

## 三、流程结构
### 1. 选择结构：
#### 三目运算符
1）语法：
		表达式1 ? 表达式2 : 表达式3
2）作用：
若表达式1为真，则 执行表达式2；
若表达式1为假，则 执行表达式3.
#### switch语句
1）作用：执行 多条件分支结构
2）语句：
```c
int main(){
	switch(表达式){
		case 结果1:
        	执行语句1; break;	// break 退出当前分支
        case 结果2: 
        	执行语句2; break;
        ...
        default: 
        	执行语句n; break;	// 都不满足，则执行这个
	}
}
```
#### if 和 switch 区别
switch：
缺点：判断时，只能是 整型 或者 字符型，**不可以是一个区间**
优点：结构清晰，执行效率高
### 2.循环结构
#### while语句
1）作用：重复执行
2）语法
```c
	while(循环条件){		// 条件为真，则一直循环
	
	}
```
#### do while语句
1）作用：先执行一次 循环语句，再进行判断条件
2）语法：
```c
	do{
		循环语句
	}while(循环条件);
```
### 3.跳转语句
#### break语句：
1) 作用：用于 跳出**选择结构 或者 循环结构**
2) 使用时机：【跳过最近的 整个循环】
	（1）在switch语句中，作用是 终止case并跳出switch
	（2）在循环语句中，作用是 跳出当前的循环语句
	（3）在嵌套语句中，作用是 跳出**最近的**内层循环语句
	break;				// 可以利用 break 退出当前循环
#### continue语句：
1) 作用：在**循环语句**中，**跳过本次循环中余下尚未执行的语句**，继续执行下一次的循环
2) 使用时机：【跳过本次循环，不再执行后面的代码】
#### goto语句：
1) 作用：可以**无条件跳转语句**
2) 语法：
	goto 标记;	   // 如果 标记的名称存在，则执行到goto时
	标记;			// 则会跳转到 标记的位置
3) 使用：
```c
	cout << "1" << endl;
	goto Flag;				// 程序运行到这时，进行跳转
	cout << "2" << endl;
	Flag;					// 直接跳转到此处执行，忽略了2
	cout << "3" << endl;	
```

# C++Primer
## 一、初始化
### 初始值

### 列表初始化
1. 定义：无论是初始化对象还是某些时候为对象赋新值，都可以使用一组**由花括号括起来的初始值**
2. 特点：当用于内置类型时，使用列表初始化且初始值存在丢失信息的风险，则编译器将会报错。


## 二、变量和基本类型
### 2.2 变量 == 对象 【对象 也是 变量 】
1. 对象 有自己的 地址。
### 2.3 复合类型
**声明语句 = 基本数据类型  声明符(变量名)**
#### 2.3.1 引用（本身不是一个对象，不能定义引用的引用，一旦定义了，九无法再绑定另外的对象）
1) 语法： **基本数据类型 &d = 变量**，其中d为声明的变量名
	【将 d 与 变量 **绑定**在一起，数据类型必须相同】
2) 例如：
```c
	int ival = 1024;
	int &refVal = inval;// refVal -> inval（为ival另一个名字）
```
3) 核心：引用是 已经存在的对象 起的另外一个名字
4) 使用：
```c
int i = refval;	// 利用与refval绑定的对象的值（inval）的值初始化
```
5) 注意：
（1）==引用必须被初始化==，引用在初始化后，不可以被改变
（2）引用类型的 初始值 必须是一个对象（变量），不能是一个数
（3）引用类型 必须 与 被引用的对象 **相同类型**。（有两种例外）
两种例外：
a.初始化常量引用（const）时，允许用任意类型的表达式作为初始值。【系统自动增加临时量】
如：
```c
	double dval = 3.14;			// 双精度浮点数定义 dval
	const int &ri = dval;		// 正确。
/** 相当于
	const int temp = dval;		// 其中 temp 为临时量
	const int &ri = temp;
*/
```
##### 引用的 本质： 在 C++内部实现一个 指针常量
1. 本质：** 指针常量**
```c
int main(){
	int a = 10;
// 自动转换为：int* const ref = &a,指针常量是指针指向不可改，说明引用也不可改
	int &ref = a;
	ref = 20;		// 内部发现ref是引用，自动转换为 *ref=20;
}

```

##### 引用 作为 函数返回值
1. 作用：引用 可以作为 函数的返回值
2. 注意：==不要返回**局部变量的引用**==
3. 用法：函数的调用可以作为==**左值**==（等号 左边的为左值）
```c
	// 不要返回 局部变量的引用
	int& test01(){
		int a=10;
		return a;
	}
	
	// 函数的调用 可以作为 左值
	int& test02(){				// 返回的 是 a的引用
		static int a = 10;		// 将局部变量 升级为 静态变量（存放在全局区）
		return a;
	}
	
	int main(){
		int &ref1 = test01();
		cout << ref1 << endl;	// 会乱码，非法操作
		
		int &ref2 = test02(); 	// ref2 与 a 绑定。ref2 为 a 的别名 
		cout << ref2 << endl;
		
		// 函数调用 可以作为 左值
		test02() = 1000;		// 将 a = 1000；则 ref2 =1000
		cout << ref2 << endl;
	}
```

#### 2.3.2 指针（pointer）
1) 语法： 声明符：** \*d **，其中d为声明的变量名
如：
```c++
	int *ip1;	// ip1是指向 int型 对象的指针
```
2) 作用：指针**存放某个对象的地址**【获取地址：用 取地址符 &】
（指针的值 即是 地址：\*p=&ival）
```c++
	int ival = 42;
	int *p = &ival;// p是指向变量ival的指针（p存放变量ival的地址）
```
3) 利用指针访问对象：使用 **解引用符 \***来访问该对象。
【对指针**解引用** 得到**所指的对象**】
注意：解引用 仅适用于 确实指向了某个对象的 有效指针。
4) 建议：**初始化所有指针**，避免出错。实在不行，用nullptr。
5) 赋值：令他 存放一个新的地址，从而 指向一个新的对象。
区分 改变指针的值 还是 改变指针所指对象的值：
【技巧：**赋值永远改变的是 等号左侧的对象**】
```c++
	pi = &ival;	// 改变的是指针的值，pi指向了ival
	*pi =0;		// 改变的是指针所指对象的值，ival=0，指针pi不变 
```
6. 指针所占内存空间：

   （1）在32位操作系统下：占 4个字节 空间

   （2）在64位操作系统下：占 8个字节 空间 
##### 空指针：
1) 定义：指针变量 指向 内存中 编号为0 的空间
2) 用途：初始化指针变量。（不知道 指向哪好）
2) 生成方式：
```c++
	int *p1 = nullptr;	// 等价于 int *p1 = 0;【常用】
	int *p2 = 0;
```
```c++
#include<cstdlic>		// 需要 前置的头文件
	int *p3 = NULL;		// 等价于 int *p3 = 0;【避免使用】
```
3) 注意：==空指针指向的内存是**不可以访问**的==
  - 原因：0～255之间的 内存编号 是 系统占用的，所以 不可以访问
##### 野指针
1) 定义：指针变量 指向 **非法的 内存空间**。
2) 代码：
```c
int main(){
	// 指针变量p 指向 内存地址编号为 0x1100的空间
	int *p = (int *)0x1100;			// (int *) 强制转换为 地址类型
	
	// 访问 野指针
	cout << *p << endl;		// 报错
}
```
3) 结论：==空指针 和 野指针 都不是我们申请的空间，因此**不要访问**==

##### void* 指针
1) 定义：
	void \* 可用于存放 **任意类型对象的地址**。
2) 使用：
```c
	void *pv = &obj;	// obj可以是任意类型的对象
```
3) 注意：不能直接操作 void\* 指针所指的对象，没办法访问内存空间中所存的对象。
3) 后续：在19.1.1节 和 4.11.3节讲述
##### 野指针（常见的 错误 ）
1) 定义：指针变量指向 非法的内存空间
2) 如：
```cpp
	int *p = (int *)0x1100;	// 该空间不是我们申请的，所以无法访问
	cout << *p << endl;		// 野指针，无法访问。报错
```

#### 2.3.3 符号的多重含义【关键概念】
根据上下文推断：
	int &r = i; // & 紧随 类型名 出现，是一个 引用声明。
	int *p;		// * 紧随 类型名 出现，是一个 指针声明。
	p = &i;		// & 出现在 表达式 中，是一个 取地址符。
	*p = i;		// * 出现在 表达式 中，是一个 解引用符。
	int &r2 = *p;// & 为 引用声明，* 为 解引用符。
#### 2.3.4 理解复合类型的声明
1. 指向 指针的指针：
```c
	int **ppi = &pi;	// 指向一个int型的指针
```
需用两次解引用。
2. 指向 指针的引用：int \*&r = p
```c
	int *p;			// p是一个 int型 指针
	int *&r = p;	// r是一个 引用，*&r是一个指向指针p的引用。（其中，符号*说明：r引用的是一个指针）
```
### 2.4 const 限定符【定义 常量】
1. 定义：当希望定义一种**常量（值不被改变的变量）**时，可以用const对变量的类型加以限定
2. 语法：
```c
	const int ci = 56;	// ci=56，在程序中无法对ci进行更改
```
## 三、字符串、向量和数组
### 3.1 String类	[#include<string>]（为一个 对象）
#### 3.1.1 定义/初始化 string 对象
```c
	string s1;		// 创建 空字符串s1

	string s2 = s1;	// s2 是 s1 的副本 （拷贝初始化）
	string s2(s1);	// 同上（直接初始化）

	string s3 = "hello world";	// s3 是该字段的 副本（拷贝初始化）
	string s3("hello world");	// 同上（直接初始化）

	string s4(10,'c');		// s4 的内容为 10个c（直接初始化）
```
### 3.1.2 string对象上的操作
#### 读写 string 对象
注意：string对象 会自动忽略开头的空白，直到遇到下一处空白为止
```c
	os << s					// 将s写到输出流os中

	is >> s					// 将 is中读取字符串 赋给s，字符串以空白分隔，返回 is
```
#### 读取一整行[getline()]
注意：只要一遇到 换行符 就结束读取操作
```c
	getline(cin,s)			// 从 cin中 读取一行赋给 s，返回cin
```
#### empty 和 size 操作
(1)定义：empty、size 是 string的一个**成员函数**，只要使用**点操作符**指明哪个对象执行就可。
```c
	s.empty()				// s 为空返回时，则为true；否则，返回false

	s.size()				// 返回 s中 字符的个数
```
(2)注意：size函数返回的是 一个**string::size_type类型**的值；且 返回的是一个 **无符号整型数**。
```c
	// 可以用 auto 与 decltype 来查看 变量的类型
```
#### 比较 string对象【注意：对 大小写敏感 】
（1）相等/不等 运算符:(==和!=)
（2）关系运算符：<、>、>=、<=
（3）比较规则：【**按字典顺序比大小**】
a. 如果两个对象，长度不同但是前面的内容相同：则 长的 > 短的
b. 如果两个对象，内容不同：则**对第一对相异字符**进行比较。
#### 两个 string对象 相加
定义：新的对象 = 将 两个对象串接起来
```c
	string s3 = s1 + s2;		// 将 s1的内容 与 s2的内容 串接后 输出为s3

	s2 += s1;					// s2 = s1 + s2
```
#### 字符串字面值("字面值") 与 string对象 相加
（1）原则：**每个+号 左右两侧 至少有一个string对象**
（2）切记：*字符串字面值 与 string对象 是不同的类型*，**字符串字面值 + string对象 = string对象**
（3）举例：
```c
	// 正确 例子
	string s3 = s1 + "," + s2;		// 字符串字面值“，” + 两边有一个string对象
	
	string s3 = s1 + "," + "hello";	// 相当于 (s1 + ",") + "hello". 其中(s1 + ",")也为 string对象

	// 错误 例子
	string s3 = "hello" + "world";	// +号两边都为字符串字面值
	
	string s3 = "hello" + "world" + s1;	// 相当于("hello" + "world")+s1. 其中("hello" + "world")里边是两个字面值相加，错误。 
```
### 3.2.1 处理 string对象 中的字符 [#include<cctype>头文件]
目的：需要 单独处理 string对象 中的字符
#### 处理每个字符[使用 基于范围的 for语句]
```c
	// expression 是一个String对象，用于处理该对象内的字符
	// declaration 负责定义一个变量，用于访问序列中的基础元素【可以使用 引用&str 来更改自己】
	for( declaration : expression)		// 每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值
		statement;						// 待实现的功能
```
举例：改变自身字符串字符
```c
	string str("hello");
	// 使用for语句 与 引用：每次迭代，c 引用 str的下一个字符
	for(auto &c : str)					// 使用 auto自动定义变量类型；引用&c，使c与str绑定，更改c就是更改str。最后输出str
		c = toupper(c);					// toupper函数是将 小写字母变为大写字母
	cout << str << endl;
```
#### 访问/处理 单个字符 的方式：（1）使用 下标 （2）使用 迭代器
##### 方法一：下标/索引 （下标符号：[ ]）
注意：s[index] 下标的类型为 **string::size_type类型**，可以使用 **decltype(str.size())来定义 index**
前提：要保证 下标必须在合理范围内： 0 <= index <= str.size()
```c
	string str("Hello");

	cout << str[0] << endl;
```
##### 方法二：迭代器（3.4节与第9章）

### 3.3 标准库类型 vector（vector容纳着其他类型的对象，也称容器）【对象】
1. vector 表示对象的集合（所有对象的类型都相同）：集合中，每一个对象 都有一个 对应的索引
2. 使用：必须包含**头文件**
```c
	#include<vector>
	using std::vector;
```
3. vector 是 类模板：使用时，需提供 **额外信息**来指定模板 到底实例化成什么样的类
提供额外信息的方法：在**模板名字后面跟一对尖括号，在括号内放上信息**
比如：
```c
	vector<int> ivec;				// ivec为保存int类型的对象
	vector<Sales_item> Sales_vec;	// 为 保存Sacles_item类的对象
	vector<vector<string>> file;	// file为保存 vector类型的对象（老式编译器可能右三角须有空格：vector<vector<string> >）
```
4. 注意：vector*不能包含引用类型*
#### 3.3.1 定义和初始化 vector对象（两个参数：容量 和 元素初值）
##### 定义vector对象的常用方法
```c
//	T 为内部元素的类型，v 为vector对象
	vector<T> v1;				// 创建 v1为空vector类对象，其内部元素为T类型，默认初始化（常用，后面再往里加值）
	
	vector<T> v2(v1);			// v2中包含v1所有元素的副本（直接初始化）【需类型相同】
	vector<T> v2 = v1;			// 同上（拷贝初始化）【需类型相同】

	vector<T> v3(n,val);		// v3包含了 n个重复的元素，每个元素的值都是val
	vector<T> v4(n);			// v4包含了 n个重复地执行了 值初始化的对象

	vector<T> v5{a,b,c,..};		// v5包含了 初始值个数的元素，每个元素被赋予相应的初始值（直接初始化）
	vector<T> v5={a,b,c,...};	// 同上（拷贝初始化）
```
##### 列表初始化 vector对象
方法：用 **花括号**括起来的0个或多个初始元素值 被赋值给vector对象。
如：
```c

	vector<string> v1{"a","an","the"};			// 列表初始化（注意：不能使用 圆括号() ）

```
##### 创建指定数量的元素
方法：
```c
	vector<int> ivec(n,a);			// 创建 n个int类元素，每个元素的值都为a

	vector<string> svec(10,"a");	// 创建 10个string类型的元素，每个元素都为"a"
```
##### 值初始化
1. 定义：只提供 vector对象容纳的 元素数量 而省略初始值。
如：
```c
	vector<int> ivec(10);			// 10个元素，都默认为0

	vector<string> svec(10);		// 10个元素，都默认为空string对象
```
2. 库会 创建一个值初始化的初值，赋给容器中的所有元素。
  - 内置类型（如:int）：元素初始值自动设置为 0
  - 类 类型（如:string）:元素由 类默认初始化

3. 限制、注意：
  - 若 元素类型不支持默认初始化，则必须提供初始化值，否则无法初始化。
  - **只提供了元素的数量**，而没有设定初始值，**只能使用直接初始化**

##### 容量还是元素初值？（使用 花括号 或者 圆括号 区分）
1. 圆括号：提供的值是用来 **构造vector对象的**
2. 花括号：列表初始化。花括号内的值，当成是**元素初始值的列表**来处理
```c
	// 区分
	vector<int> v1(10);				// v1有10个元素，每个值都是0
	vector<int> v2{10};				// v2只有1个元素，其值为10
	
	vector<int> v3(10,1);			// v3有10个元素，每个值都是1
	vector<int> v4{10,1};			// v4有2个元素，一个10,一个1
```
3. 若使用花括号形式，但是**提供的值不能用来初始化**，则用默认值初始化对象。（如：类型不符等）
```c
	vector<string> v1{"hi"};		// 列表初始化
	vector<string> v2("hi");		// 错误。不能用圆括号

	vector<string> v3(10);			// v3有10个默认初始化的元素（因为10不为string类型）
	vector<string> v4{10,"hi"}		// v4有10个值为"hi"的元素（因为10不为string类型，使用默认初始化对象）
```
#### 3.3.2 vector 中添加元素
1. 方法：
   第一步：先创建一个 空vector：`vector<类型> v1`
   第二步：再使用 `v1.push_back(元素)`向其中添加元素。
2. 语法： 
```c
	vector<int> v1;			// 创建空vector

	v1.push_back(i);		// 将 元素i 添加至 vector后面

```
3. 注意事项：
  - 必须要确保所写的 **循环正确无误**
  - 循环体内部 **包含有vector对象添加元素的语句**，则 **不能使用范围for循环**

#### 3.3.3 其他 vector操作
1. 语法：
```c
	v.empty()					// 如果v中不含有任何元素，则返回真；否则为假

	v.size()					// 返回 v中元素的个数

	v.push_back(t)				// 向v的尾端 添加一个值为t的元素

	v(n)						// 返回 v中第n个位置上元素的引用

	v1 = v2						// 将 v2中的元素 拷贝至v1
	
	v1 = {a,b,c,..}				// 用 列表中元素的拷贝 替换 v1中的元素

	v1 == v2 					// 若 v1与v2中的对应位置元素 完全相同 ，则 返回真

	v1 != v2					// v1与v2 元素不同，则为真

	<,>,>=,<=					// 以 字典顺序进行比较

```
2. 举例：
- 使用**范围for语句**处理vector对象中的**所有元素**：【**&i:v**：引用i，并将其与v中元素绑定】
```c
	vector<int> v{1,2,3,4,5,6,7,8,9};		// 创建向量v，并设置初值

	//范围for语句
	for( &i : v )			// 引用i，并将i与v绑定：改变i，即改变v中元素。i从1开始，往上迭代
		i *= i;				// i = i*i
	
	for( i : v )			// 调用i，遍历v中元素（i从1开始，往上迭代）
		cout << i << endl;	// 打印
	
	答案：
	1 4 9 16 25 36 49 64 81
```
- `v.size()`返回vector对象中元素的个数，其类型为由 vector<类型> 定义的 size_type类型
```c
	// vector对象的类型，总是包含着元素的类型
	vector<int>::size_type
```
- 只有当**元素的值可以比较时**，**vector对象才能被比较**
	如：
	string类，定义了自己的关系运算符，所以 可比较；
	size_type类，未定义关系运算符，所以 不可比较。
#### 3.3.4 计算 vector内对象的 索引
1. 方法：使用**下标运算符[]**获取指定的元素。`v[i]`（从0开始）
2. 下标的类型：`size_type`类型
3. 注意：只要vector对象**不是一个常量**，就可通过下标运算符返回的元素**赋值**
##### 注意：
1. 不能用 下标形式（索引） 添加元素：下标形式 只能用于访问元素，不能添加元素
2. 只能对 **确知已存在**的元素执行 下标操作。

##### 技巧：确保下标合法的一种有效手段：尽可能使用 范围for语句


## 六、函数
### 6.1 函数基础
1. 定义：包括 返回类型return type、函数名字、由0个或多个形参
2. 函数的三要素：**返回类型、函数名、形参类型**描述了 函数的接口
` 返回类型  函数名(形参类型1 变量1，形参类型2 变量2){... return 返回类型的变量}`
##### 实参与形参
1. 形参：
  - 函数的形参 列表可以为空但是不能省略。
  - 定义一个不带形参的函数，最常用关键字`void`表示
  - 形参列表中，形参通常用 逗号隔开；且 **每个形参都含有一个声明符的声明**。
```c
	// 空形参
	void f1(void){}

	// 函数声明
	int f2(int i,int j){}
```
1. 实参： 
  - 实参 是 形参的 初始值。
  - 且 实参与形参 一一对应。
  - **实参的类型 必须与 形参的类型 相同**
  - 函数有几个形参，就必须提供 相同数量的实参。**实参 与 形参 数量上必须一致**

2. 函数返回类型：
  - 特殊：空返回 void，表示 函数部返回任何值
  - 注意：函数的返回类型 **不能是 数组类型(3.5节) 或 函数类型**。但可以是 指向数组或函数的指针（6.3.3）.
#### 6.1.1 局部对象
1. 重点：**对象 有 生命周期**
2. 定义：形参和函数体内部定义的变量 统称为 局部变量。
##### 自动对象
1. 定义：只存在于 **块执行期间的对象** 称为自动对象。
2. 生命周期：其 当程序经过变量定义语句时，创建该对象；当到达块执行结束后，销毁该对象。
##### 局部静态变量
1. 定义：将局部变量 定义成 `static类型`的对象
```c
	int count()
	{
		// 局部静态变量 static
		static int i = 0;
	}
```
2. 生命周期：当 程序第一次经过时，初始化对象；**直到 所有程序终止时，才被销毁**。[在函数外,无法调用该静态变量]
3. 注意：如果局部静态变量没有显式的初始值，它将执行 值初始化。

#### 6.1.2 函数声明
1. 函数的名字，必须在使用之前声明
2. **函数只能定义一次**，但可以声明很多次。
3. 函数声明时，最好 带上形参。（可不带）
##### 在头文件中 进行函数声明
建议：
- 变量：在 源文件中定义，在 头文件中声明。
- 函数：在 **源文件中定义**，在 **头文件中声明**。

#### 6.1.3 分离式编译
1. 分离式编译 允许我们把程序分割到几个文件中去，每个文件独立编译。 

### 6.2 参数传递
两种参数传递方法：
- 当形参是**引用类型**时：其 对应的实参被**引用传递** 或者 函数被**传引用调用**。【==引用形参时其对应的实参的别名==】
- 当形参是**非引用类型**时：其对应的实参被**值传递** 或者 函数被**传值调用**【==实参的值 被拷贝给 形参，形参和实参时两个相互独立的对象==】

#### 6.2.1 传值参数调用 (不改变实参)
1. 变量：当 初始化一个非引用类型的变量 时，初始值被拷贝给变量。【**对变量的改动不影响初始值**】
2. 函数：实参初始化形参 时，实参的值被拷贝给形参。函数对形参做的所有操作，都**不会影响实参**。
##### 指针形参
1. 与 非引用类型相同: 当 执行指针拷贝操作时,拷贝的是 **指针的值**.拷贝之后,两个指针是不同的指针.

#### 6.2.2 传 引用参数 (改变实参)
1. 重点: 通过使用**引用形参**,允许函数==改变一个或多个实参的值==
2. 如:
```c
	// 此时, &i 表示 传入的实参的另一个 别名 [就是 实参本身]
	void reset(int &i){
		i = 0;				// 传入的实参 为 0.改变i 就是 改变实参本身
	}
```
##### 使用 引用 避免拷贝
1. 有些类 类型 不支持拷贝.
2. 当某种类型不支持拷贝操作时,函数只能通过**引用形参**访问该类型的对象.
3. 如： 比较 两个string对象的长度 （*string对象 不能 使用拷贝*）
```c
	// 比较 两个 string对象的长度
	bool isShorter(const string &s1,const string &s2){
		return s1.size() < s2.size();
	}
```
4. 技巧：==无需改变引用形参的值时，将其声明为**常量引用**==

###### 使用 形参 返回额外的信息【重点】
1. 原因：一个函数只能返回一个值
2. 解决方法：使用**引用形参 可以返回 多个结果** 。
3. 如： 
    返回string对象中某个指定字符 第一次出现的位置
```c
	// 返回s中c第一次出现的位置索引
	// 其中，引用形参occurs 负责统计c出现的次数
	// 其中，size_type 是在 string的命名空间中的
	string::size_type find_char(const string &s,char c,string::size_type &occurs){
		auto ret = s.size();		// 第一次出现的位置
		occurs = 0;
		for(decltype(ret) i=0;i!=s.size();i++){
			if(s[i]==c){
				occurs++;			// 通过occurs来统计c出现的次数
				if(ret==s.size())
					ret = i;
			}
		}
		return ret;
	}
```
#### 6.2.3 const形参和实参
1. 当 形参是 const 时：
  - 顶层const：（顶层 const 作用于 **对象本身**）
	当==实参初始化形参时，会**忽略掉顶层const**==
  - 底层const：指针所指 对象是常量

##### 指针 或 引用形参 与 const【重点】
1. 可以 使用非常量 初始化一个 底层const对象，但 反过来不行。
2. 一个 普通的引用 必须用 **同类型的对象初始化**
如：
```c
	int i = 42;
	const int* cp = &i;		// 底层const，cp指向的内容为常量，cp不能改变i
	const int &r = i;	// 底层const，被引用的内容为常数，r不能改变i
```
```c
	reset(&i)		// 调用形参类型是 int* 的 reset函数
	reset(i)		// 调用形参类型是 int& 的 reset函数
```
3. 注意：
  - 调用 引用版本的函数：只能使用int类型的对象，而*不能使用字面值、const int类型等*。
  - 调用 指针版本的函数：只能使用** int\*类型的对象**
  - C++允许 用**字面值 初始化 常量引用**
##### 尽量使用 常量引用
1. 使用 非常量引用 会极大地限制函数所能接受的实参模型。
2. 注意：==字面值 是一个 常量引用==。（非常量引用，无法调用 字面值）
#### 6.2.4 数组形参
1. 两个特殊性质：（对作用在数组上的函数有影响）
  - **不允许拷贝数组**。（无法 值传递 ）
  - 使用数组时，会将其**转换成指针**（注意：数组名就是数组的首地址）
当为函数传递一个数组时，实际上传递的是 指向数组首元素的指针

2. 形参为 数组 的函数，三种表现形式：
```c
	// 三种方式 等价
	void print(const int*);			// 常用
	void print(const int[]);		// 常用
	void print(const int[10]);
```
3. 当实参为数组时，实参 自动地转换成 *指向数组首元素的指针*，数组的大小对函数的调用没有任何影响。
##### 管理数组实参（数组形参）的方法【需要提供 数组长度的信息】
###### 方法一：使用 标记 指定数组长度
1. 方法：要求数组本身==包含一个**结束标记**==。（C风格的字符串）
2. 原理：函数在处理C风格字符串时，遇到**空字符**则停止
3. 如：
```c
	void print(const char* cp){
		if(cp)			// 若cp不是空指针
			while(*cp)			// 只要 指针所指不是 空字符
				cout << *cp++;	// 指针往后移动，输出
	}
```
###### 方法二：使用 标准库规范
1. 方法：==传递指向 数组**首元素和尾元素的指针**。
2. 原理：需要输入**首指针和尾指针**
```c
	// 函数定义
	voide print(const int *beg,const int *end){
		// 输出 beg 到 end之间（不含end）的所有元素
		while(beg != end){
			cout << *beg++ << endl;
		}
	}
// 函数调用：需 传入两个指针，一个指向待输出的首元素，一个指向待输出尾元素的下个位置
	int j[2]={0,1};
	print(begin(j),end(j);)		// begin、end 在第106页
```
###### 方法三：显式传递  一个表示数组大小的 形参
1. 方法：专门==定义一个**表示数组大小的形参**==（C中常用）
2. 
```c
	// size 表示数组的大小，用于 控制对ia的访问
	// ia[] 等价于 int *ia
	void print(const int ia[], size_t size){
		for(size_t i=0; i!=size ; i++){
			cout << ia[i] << endl;
		}
	}
```
3. 注意：传递的 size值 不要超过数组的 大小
##### 数组形参 和 const
1. 当 函数的数组元素**不需要进行写操作时**，数组形参 应该是 **指向const的指针**。
2. 当 函数要**改变数组元素值**时，形参应定义成**非常量指针**。
##### 形参 为 数组的引用
1. 形参 可以为 数组的引用。
2. **引用形参 绑定到 对应的实参上**，也**绑定到数组上**。
3. 注意：是==(&arr)[10]==（arr是10个整数的整型数组的引用），**括号必不可少**
	    不是&arrr[10]（arr 声明成 引用的数组）
```c
	void print(int (&arr)[10]){
		for(auto elem : arr)
			cout << elem << endl;
	}
```
4. 其 ==实参 需为 含有10个整数的 数组==
##### 传递 多维数组
1. 本质： 多维数组 其实是 **数组的数组**
2. 其  首元素本身 就是一个数组，指针 就是一个 **指向数组的指针**
3. 注意：
  - **\*matrix两端括号，必不可少**
  - **数组的 第二维，必不可少**	   
```c
	// 下面均为 等价
	void print(int (*matrix)[10]){}		

	void print(int matrix[][10],int rowSize){}	
```
#### 6.2.5 main函数
1. main函数定义
```c
	// 等价
	int main(int argc,char *argv[]){}
	
	int main(int argc,char **argv){}
```
其中：
  - argc： 表示 代码数组中 **字符串的 数量**
  - argv：该 形参 表示 **数组**
2. 给 main函数 传递形参
```c
	// 假设 main函数 在可执行文件prog中
	prog -d -o ofile data0
	/* 其中：argc = 5
			argv[0]="prog",argv[1]="-d",...,argv[5]="0"
	*/      
```
3. 注意：当使用argv中的实参时，**可选的实参从argv[1]开始**，argv[0]为保存程序的名字
### 6.3 函数的提高
#### 6.3.1 函数 的 默认参数
1. 在c++中，函数的形参 可以有 **默认值**的。
2. 语法：`返回值类型 函数名(参数 = 默认值){}`
```c
int func(int a,int b=20,int c=30){
	return a+b+c;
}
int main(){
	// 如果没有传入值，则用默认值
	cout << func(10) << end;		// 可以省略 默认的实参
	// 如果传入了值，则用 传入的实参
	cout << func(10,20) << endl;
}
```
3. 注意事项：
  - 如果某个位置有了 默认参数，则从这个位置**往后，从左到右都必须有默认值**。
  - 如果 函数**声明有了默认参数**，则函数的**实现就不能有默认参数了**。
```c
// 函数 声明 
int func(int a=10,int b=10);			// 函数声明 有默认参数
// 函数 实现
int func(int a,int b){					// 函数实现，就不能有默认参数了
	return a+b
}
// 声明 和 实现 只能有一个 有默认参数。
```
#### 6.3.2 函数的 占位参数
1. c++函数 的 形参列表里 可以有 **占位参数**，**调用函数时，必须填补该位置**
2. 方法：在 形参中 只写 **数据类型**，不写 变量
3. 语法：`返回值类型 函数名 (数据类型){}`
4. 默认参数： 占位参数，可以有 默认参数
5. 注意：调用函数时，**占位参数必须填补**
```c
// 占位参数
void func1(int a,int){			// 第二个 形参 int 就是占位参数

}
// 占位参数，可以有 默认参数
void func2(int a, int = 10){

}

int main(){
	fun1(10,20);	// 调用函数时，占位参数必须填补
}
```
### 6.4 函数 重载
#### 6.4.1 重载 概述
1. 定义：**函数名相同**，但是 **形参不同**。（函数名相同，可以提高 复用性）
2. 满足条件：（三个都必须满足）
- ==同一个作用域下==
- ==函数名称相同==
- 函数的形参 ==类型不同==，或者==个数不同==，或者==顺序不同==
3. 注意：函数的返回值 不可以作为 函数重载的条件
```c
	// 函数名 相同 ； 但是 形参 不同
	void func(){				// 形参 没有参数
		
	}
	void func(int a){			// 形参 有 整型参数
	
	}
	// 注意： 函数的返回值 不可以作为 函数重载的条件。
```
#### 6.4.2 函数重载 的 注意事项
1. **引用** 作为 重载条件：
  - const 与 无const 为 **不同类型 形参**
```c
	void func(int a){};				// 形参 为 int
	void func(const int a){};		// 形参 为 const int
	
	int main(){
		int a = 10;
		func(a);		// 调用 形参 为 int的函数。（因为 a 为 变量，非常数）
		func(10);		// 调用 形参 为 const int的函数。（因为 10 为常数）
	}
```
2. 函数重载 碰到 函数**默认参数** 
  - 会出现 二义性 报错。（**尽量避免 使用 默认参数**）
```c
	void func2(int a,int b=10){};
	void func2(int a){};
	int main(){
		func2(10);			// 会出错，具有歧义
	}
```


## 七、类 和 对象【重点！！！】
1. 面向对象 的 三大特性：
- ==封装==
- ==继承==
- ==多态==
2. 对象：**万事万物都皆可对象**，对象上 有其 属性和行为。

3. 类：具有**相同性质**的对象，可以抽象为一个**类**。
  - 基本思想：类 的基本思想是 **数据抽象**和**封装**。
    - 类的接口：
    - 类的实现：
4. 数据抽象：是一种依赖于==接口和实现==**分离**的编程技术。
### 7.1 封装
#### 7.1.1 封装的意义
- 将  属性和行为  作为一个**整体**，表现生活中的事物
- 将 属性和行为 加以**权限控制**
- 类 中的 属性和行为，统称为**成员**
1. ==封装一个类==：
在 设计类的时候，将 属性和行为 写在一起，表现事物：
```c
	class 类名{
	访问权限:
		属性（成员数据）;
		
		方法（成员函数）;
	};
```
2. ==实例化==：根据类的模板，来创建一个**对象**的过程。
```c
	int main(){
		类名 对象名;
	}
```
3. 对 类的对象 的使用：
- public 的内容：==使用**点运算符**==
```c
int main(){
	类名 对姓名;
	//对 类对象 的（public）属性进行赋值
	对象名.属性 = ;
	// 调用 类对象 的 方法
	对象名.方法();
}
```
4. 类内 可以 **初始化数据**。
#### 7.1.2 访问权限
类在设计时，可以把 属性和行为 放在不同的权限下，加以控制。
1. ==public ：公共权限==   	   ：   类内可以访问，类外可以访问
2. ==protected ：保护权限==    ： 类内可以访问，类外不可以访问 【子类可以访问父类中保护权限的内容】
3. ==private ：私有权限==	：  类内可以访问，类外不可以访问 【子类不可访问父类中私有权限的内容】
4. 当 不写 访问权限时，为**private 权限**
```c
class 类名{

private:	// 默认权限
	string name = "zyx";	// 类内 可以 初始化 给变量赋值
protected:
	int age;
public:			// 在 类内 可以直接调用 私有权限和保护权限 的成员
	void func(){
		age = 25;
	}
};
int main(){
	// 实例化对象
	
	// 保护权限 和 私有权限 的 成员 无法在类外访问
	类.name / 类.age 不能访问
}
```
5. 在类中 可以让 ==另一个类 作为 **本类的成员**==，使用`类1.类1接口.类2接口`来调用（见：relate.hpp）

##### struct 与 class  的 区别：
- struct：默认权限是 **public 公有权限**
- class：  默认权限是**private 私有权限**
#### 7.1.3 成员属性 设置为 私有
1. 技巧：将 ==成员属性/数据 设置为 **私有**==
2. 优点：
- 将所有成员属性设置为 私有，可以自己控制 读写权限
- 对于 写权限，可以检测数据的有效性
3. 要想 写入或读取 私有的成员属性：需通过**public 中的 成员函数**作为接口，供使用者用。

### 7.2 对象的 初始化 和 清理
#### 7.2.1 构造函数（初始化） 和 析构函数（清理）
1. 初始化和清理 是重要的问题：
  - 一个对象或者变量没有初始状态，对其使用后果是未知的
  - 使用完一个对象或变量，没有及时清理，也会造成一定的安全问题
2. 构造函数和析构函数 是 **编译器自动调用**，完成初始化和清理的工作。
3. 如果 我们不提供构造和析构，则编译器会提供。
  - 但是，**编译器提供的构造函数和析构函数 是 空实现**
4. 定义：
  - ==构造函数==：作用于 **创建对象时**为对象的成员属性**赋值**，构造函数由编译器自动调用，无需手动调用。
  - ==析构函数==：作用于 对象**销毁前**系统自动调用，执行 清理工作。【通常，析构代码，==用于将**堆区**开辟的数据进行**释放**==】


##### 构造函数【public权限】
1. 语法：`类名() {}`
  - 构造函数：*没有返回值，也不写void*
  - 函数名称 与 类名相同
  - 构造函数 可以有参数，因此可以发生 函数重载。（也可以 不写 形参）
  - 程序在调用对象时，会自动调用构造，无需手动调用 且 只会调用一次
```c
class Person{

public:			// 构造函数 在 public下
	// 构造函数
	Person(){				// 可以 有形参 或 无参
		// 可以自己加内容 ，但 只会被调用一次
	}				
}
int main(){
	Person p;		// 在 实例化 时，便会 自动 调用构造函数
}
```

##### 析构函数【public权限】
1. 语法：`~类名() {}` 
  - 析构函数：*没有返回值，不写void*
  - 函数名称 与 类名相同，并 在名称前加上符号～
  - 析构函数**不可以有参数**，因此不可以发生重载
  - 程序在对象销毁前会 自动调用析构函数，无需手动调用 且 只会调用一次
```c
class Person{

public:
	～Person(){				// 析构函数 不可以 有形参
		// 自定义功能
	}
}
void test(){
	Person p;				// 实例化，便初始化了
}
int main(){
	test();					// 在栈上的数据，test执行完毕后，便会释放这个对象
}
```
#### 7.2.2 构造函数的分类 与 调用
1. 两种 ==分类方式==：
  - 按**参数**分为：有参构造 和 无参构造（默认构造）
    - 有参构造：有 形参
    - 无参构造：无 形参
  - 按**类型**分为：普通构造 和 拷贝构造
    - 拷贝构造函数：构造函数的形参为`const 类名 &类对象`
    - 普通构造函数：除了 拷贝构造 外，都为 普通构造
```c
class 类名{
public:
	// 普通构造函数
	类名(){}				 // 无参构造
	类名(参数){}			// 有参构造
    // 拷贝构造函数
    类名(const 类名 &类对象){	 // 拷贝构造，拷贝出 一模一样的类 出来
    	// 将 传入对象 的属性，拷贝到 该函数身上
    	属性 = 类对象.属性;
    };
    // 比如：
    Person(const Person &p){
    	age = p.age;
    }
}
```
2. 三种 ==调用方式==：
  - ==括号法==：【常用】
    - **默认**构造函数：`类名 类对象`		【没有 括号】
    - 调用 **有参构造**：`类名 类对象(实参);` 
    - 调用 **拷贝构造**：`类名 类对象(类对象2);`【复制 一个 新的 类对象】
    - 注意事项：调用**默认构造函数**时，**不要加 ()**.（加括号，编译器会认为是 函数声明） 
  - ==显示法==：
    - 调用 **有参构造**：`类名 类对象 = 类名(实参)`
    - 调用 **拷贝构造**：`类名 类对象 = 类名(类对象2)`
    - 注意事项1：==创建**匿名对象：`类名(实参)`**==，其特点：当前行执行结束后，系统会立即回收掉 匿名对象
    - 注意事项2：*不要利用 拷贝构造函数，来 初始化 匿名对象*。
    不能使用`类名(类对象1);`。因为 编译器会默认`类名(类对象)= 类名 类对象`，重复定义。
  - ==隐式转换法==：
    - 调用 **有参构造**：`类名 类对象 = 实参`（相当于 显示的调用）
    - 调用 **拷贝构造**：`类名 类对象 = 类对象2`
#### 7.2.3 拷贝构造函数 调用时机（三种情况）
1. ==使用 一个 已经创建完毕的对象，来 **初始化一个新对象**==
2. 以 **值传递的方式** 给 函数参数传值。
3. ==用 **值方式** 返回 局部对象==
```c
class Person{
public:
	// 创建 有参构造函数
	Person(int age){
		m_age = age;
	}
	// 创建 拷贝构造函数
	Person(const Person &p){
		m_age = p.m_age;
	}
}
int main(){
	// 调用 拷贝构造函数
	// 1. 使用 一个 已经创建完毕的对象，来 初始化一个新对象
	Person P1(20);
	Person P2(p1);			// 调用 拷贝构造函数.把p1中的内容 拷贝过来
	// 2. 值传递的方式 
	void doWork(Person p){		// 值传递 的方法。Peroson p 为 函数的形参
	
	}	
    Person p;
    doWork(p);					// 调用 拷贝构造函数（不会改变 p 的 内容）
    // 3. 值方式返回
    Person doWork2(){
    	Person p1;
    	return p1;				// 返回时，会根据p1,拷贝一个新的对象 返回。（对里面的p1对象无任何影响）
    }
    Person p = doWork2();		// 调用 拷贝构造函数
}
```
#### 7.2.4 构造函数 调用规则 【重点】
1. 默认情况下，C++编译器 至少给 一个类 添加3个函数：（默认添加）
  - 默认构造函数（无参，函数题为空）
  - 默认析构函数（无参，函数题为空）
  - 默认拷贝构造函数，对 ==属性进行 **值拷贝**==
2. 构造函数 ==调用规则==如下：
  - 如果 ==用户定义**有参构造函数**，C++不再提供 默认无参构造，但是 会提供 默认拷贝构造函数==
  - 如果 ==用户定义**拷贝构造函数**，C++不再提供 其他构造函数。==
```c
class Person{
	/*
	Person(){
		cout << "默认构造函数调用：" << endl;
	}
	Person(int age){
		cout << "有参构造函数调用：" << endl;
		m_age = age;
	}
	*/
	Person(Person p){
		cout << "拷贝构造函数调用：" << endl;
		m_age = p.m_age;		// 编译器 自动添加 只有这个赋值操作
	}
	~Person(){
		cout << "默认析构函数调用：" << endl;
	}
}
int main(){
	// 创建 对象
	Person P;		// 回报错，因为定义了 拷贝构造，就没有其他普通构造函数了/
					// Person P 为 默认构造函数 实例化
}
```
#### 7.2.5 深拷贝 与 浅拷贝
1. ==浅拷贝==：简单的 **赋值拷贝**操作
  - 利用 编译器提供的 拷贝构造函数，会做 浅拷贝操作
  - 带来的问题：**堆区的内存 重复释放**
```c
// 浅拷贝
class Person{
public:
	// 有参构造函数
	Person(int age,int height){
		m_age = age;
		// new int() 返回的是 int* 类型
		// 将 传入的实参 height 开辟在 堆区
		// 指针存放在 p中
		m_height = new int(height);	// 在 堆区 开辟 新的数据，需用指针、接收
	}
	
	// 析构函数（用于 将堆区 开辟的数据 做释放操作）
	~Person(){
		// 对 new开辟的数据 进行 释放
		if(m_height != NULL)		// 如果 m_height指针不为空
		{
			delete m_height;		// 释放 堆区数据
			m_hight = NULL;			// 将 指针 置 空
		}
	}
	// 设置参数
	int m_age;
	int *m_height;				// 设置 一个int型指针，为了接收new类型数据
}
void test(){
	Person p1(18,160);
	cout << "p1的身高为：" << *p1.m_height << endl;
	// 由于 先进后出，p2执行完，会 释放堆区。 p1无法析构，回报错。
	Person p2(18,150);				// 堆区的内存，重复释放
}
```
2. ==深拷贝==：在 **堆区 重新申请 空间**，进行 拷贝操作
  - 解决 堆区内存重复释放 的问题
  - 使用 **自己写的拷贝构造函数**，解决 浅拷贝带来的问题
```c
class Person{
public:
	// 因为 new int() 返回的是 指针类型，所以 需要创建一个指针 来接收数据
	int *m_height;		// 创建一个指针
	// 自己实现 拷贝构造函数，解决 浅拷贝的问题
	Person(const Person &p){
		cout << "拷贝 构造函数 调用 " << endl;
		// m_height = p.m_height;		//编译器默认 实现这行代码
		/*		深拷贝 操作		*/
		// *p.m_height 为了 获取 具体数值，并且在 堆区重新申请空间
		m_height = new int(*p.m_height);	// ()中，应该为 数据，但是 m_height 为 地址，所以需要 解引用  
	}
}
```
3. 栈 的 方向：先进后出

#### 7.2.6 初始化列表
1. 作用：C++提供了 初始化列表，用来**初始化属性**。
2. 语法1：值无法改变：`构造函数() : 属性1(值1),属性2(值2),...{}`
3. 语法2：值可以改变：`构造函数(类型 变量) : 属性1(变量),...{}`
```c
class Person{
public:
	int m_a;
	int m_b;
	/*		初始化属性	*/
	// 1. 初始化列表 来 初始化属性
	Person():m_a(10),m_b(20){
	
	}
	// 2. 初始化列表 来 改变属性
	Person(int a,int b):m_a(a),m_b(b){
	
	}
}
int main(){
	// 1. 利用 初始化列表 初始化
	Person p;
	// 2. 构造函数对象化 进行初始化 操作
	Person p(10,20);

}
```
#### 7.2.7 类对象 作为 类成员‘
1. C++类 中的成员 可以是 另一个类 的对象，我们称 该成员为 **对象成员**
2. B类 中 有对象A 作为成员，A为 对象成员
```c
class A{};
class B{
	A a;		// A 类的对象
}
```
3. 相关问题：
  - 先有 A类，还是 先有B类：**先有A类**
  - 当 其他类对象 作为 本类成员，==构造顺序== ：**先构造 A类对象，再构造 B自身**
  - ==析构顺序==：**先释放 B类自身，再 释放A类对象**（与 构造 相反）
```c
class Phone{		// 手机类
public:
	string m_phone;
	Phone(string Name){
		m_phone = Name;
	}
};
class Person{		// 人 类
public:
	string m_Name;		// 姓名
	Phone m_phone;		// 手机类 手机
	// 构造函数
	Person(string name,string pName):m_Name(name),m_phone(pName){
		// 相当于 Phone m_phone = pName
	}
};
void test(){
	Person p("zyx","Huawei");
	cout << p.m_name << "持有" << p.m_phone << endl;
}
```
#### 7.2.8 静态成员
1. 静态成员：==在 成员变量 和 成员函数 前加上 关键字 **`static`**==
2. 静态成员 分为：
- 静态成员 **变量**
- 静态成员 **函数**
##### 静态成员 变量
1. 性质：
- 所有对象 ==共享 同一份数据==（谁改，这个数据都会被更改）
  - 静态成员 不属于 某个对象上，所有对象 共享 同一份数据
- 在 编译阶段 分配内存（运行之前，在==全局区==就分配了内存）
- ==类内声明，类外初始化==
  - 类内 声明：在 类 中：** `static 变量类型 静态变量;`**
  - 类外 初始化：在 类 外：**`变量类型 类名::静态变量;`**
2. 声明 与 初始化：
```c
// 静态 成员变量
class Person
{
private:
    /* data */
public:
    // 所有对象 共享同一份 数据
    // 类内声明 ， 类外初始化
    static int m_A;             // 类内声明

};
// 类外 初始化
int Person::m_A = 100;

// 共享 同一份数据
void test01(){
    Person p;
    cout << p.m_A << endl;

    Person p2;
    p2.m_A = 200;           // 共享 同一份 数据；m_A会被 改为 200
    cout << p.m_A << endl;
}
```
3. 静态变量 两种 **访问方式**：
  1) 通过 ==对象== 进行 访问：`类对象.静态变量`

  2) 通过 ==类名== 进行 访问：**`类名::静态变量`**
4. 注意：
  - 静态成员变量 也是有 **访问权限** 的
    - public：类外 可以访问
    - private：类外 访问不到 （也需要 类外 初始化）
##### 静态成员 函数
1. 性质：
  - 所有对象 ==共享 同一个函数==
  - ==静态成员函数 只能访问 **静态成员变量**== （不可以访问 非静态成员变量）
2. 声明 与 初始化
3. 两种 访问函数 的方式：
  1) 通过 ==对象== 进行 访问：`类对象.静态函数();`

  2) 通过 ==类名== 进行 访问：**`类名::静态函数();`**
4. 静态成员函数 也是有**访问权限**的：
  - 在 private中定义：类外 无法 访问 私有成员函数

### 7.3 C++对象模型 和 this 指针
#### 7.3.1 成员变量 和 成员函数 分开存储
1. 在 C++中，类内的 成员变量 和 成员函数 **分开存储**。
2. 总结：==只有 **非静态成员 变量** 才 **属于类的对象**上==
```c
// 有 成员变量 的 类
class Phone
{
private:

    int m_A;        // 非 静态 成员变量，属于 类的对象 上

    static int m_B;     // 静态成员变量，不属于 类的对象 上

    void func(){}       // 非静态成员函数，不属于 类的对象 上

    static void func(){}       // 静态成员函数，不属于 类的对象 上

};
int Phone::m_B = 10;     // 类外初始化
```
3. 注意：==空对象 占用的内存大小 为 **1**==
```c
// 空类
class Person
{
};
void test01(){
    Person p;

    // 查看 空类对象 占用 多少内存：1 字节
    // 因为 C++ 编译器 会给 每个 空对象 分配一个字节空间，是为了 区分 不同空对象 占内存的位置
    // 每个 空对象 应该有一个 独一无二 的内存地址
    cout << "空类对象 占用 内存大小为 " << sizeof(p) << endl;
}
```
#### 7.3.2 this 指针 的 概念
##### 背景
1. 原因： 成员变量 和 成员函数 分开存储，
2. 结果：每一个 非静态成员函数 只会诞生 **一份 函数实例**
3. 性质：==多个 同类型的 对象 会 **共用 一块代码**，需要 区分哪个对象 调用函数==
4. 注意：**静态函数 没有this指针，因为 静态函数不属于 某个对象**
5. 问题：这函数代码 如何区分 哪个对象调用自己？
##### this指针
1. this指针：==this指针 指向 **被调用的成员函数 所属的对象（谁调用，this指向谁）**==
  - this 为 指向 类对象 的 **指针**
  - \*this 为 指向 类对象 **本身**
2. 本质：是==指针常量==，**指针的指向 不可以 修改** 
3. 性质：
  - this指针 是 隐含每一个 非静态成员函数 内的 一种 指针
  - this 指针 **不需要定义，直接使用** 即可
4. 用途：
  1) 当 **形参 和 成员变量 同名** 时，可用 this指针 来区分。（**解决名称冲突**）
  2) ==在 类的非静态成员函数 中 **返回对象本身，可使用`return *this`**==
- 注意：若使用`return *this`返回 类对象本身，则 ==函数返回类型 需为**`类名&`**==【需使用**引用&**来作为 返回，否则 返回的是拷贝 创建出 的新对象，而不是 原对象本身】
4. **引用**的用途：若使用 **引用来返回，则不会创建新对象** 来返回。
  - ==引用 指向 本身，非引用 则为 拷贝==
```c
// 若要 返回 类对象本体，需要使用 引用的方式 来 返回。
//（若不用引用，则为 值传递：会复制出新的对象来 接受返回。【类似 拷贝构造函数】）
Person& PersonAddAge(Person &p){
    // 通过 return *this 来 返回 类对象
    return *this;   // this 为 指向 p2的 指针，*this 指向的是 p2这个对象本体
    }
```
4. 代码：
```c
class Person
{
private:
    /* data */
public:
    // 构造函数
    Person(int age){
        // age = age;          // 会认为 三个 age 为 同一个。而不是 成员属性
        // 使用 this指针，与 同名 形参 进行区分
        this -> age = age;                      // this指针，指向的是 被调用的成员函数 所属的对象
    }
    
   // 若要 返回 类对象本体，需要使用 引用的方式 来 返回。（若不用引用，则对象变了）
    Person& PersonAddAge(Person &p){

        this->age += p.age;             // 将 p.age 加到 自身 age中

        // 通过 return *this 来 返回 类对象
        return *this;                   // this 为 指向 p2的 指针，*this 指向的是 p2这个对象本体
    }
    int age;
};
```
#### 7.3.3 空指针 访问 成员函数
1. C++中 空指针 也是可以 调用成员函数的，但是 要注意 有没有用到 this指针。
  - 若 使用this指针，需检查 this是否指向 成员属性；若指向成员属性，则报错。（因为 空指针 对象 没有 属性）

2. 如果用到 this指针，需要加以判断 保证代码的健壮性。
==提高健壮性==：
```c
class Person{
public:
	
	void func(){
		// 为了提高健壮性，需要在 成员函数中 都 加上一条语句
		if( this == NULL )
			return;					// 若为空指针，则返回
	
	}

};
```
#### 7.3.4 const 修饰 成员函数
1. 常函数 ：
  - 定义：成员函数后 加 const 称为 **常函数**
  - 注意：常函数内 不可以 修改 成员属性
  - **重点**：成员属性 声明时 加==关键字`mutable`==后，在常函数中 可以 修改成员属性
```c
class Person{
public:
	// this 指针，本身是 不可以 修改指向的（顶层const）
	// 在 成员函数 后面 加 const：使 指针指向的 值 不可以修改（底层const）
	// 相当于：const Person * const this
	void func() const
	{
		this -> m_A = 100;			// 报错
		this -> m_B = 100;			// 正确
	}
	int m_A;
	mutable int m_B;			// 加入mutable，常函数中 可以修改这个值
};
```
2. 常对象：
  - **声明对象前，加const**，称为 常对象
  - ==常对象 只能 调用 常函数==
  - ==常对象 可以 修改 **`mutable`定义**的成员属性==
```c
void test(){
	
	const Person p;		// 在对象前 加 const，变为 常对象
	
	p.m_A = 100;		// 报错。 常对象 无法修改 成员属性
	
	p.m_B = 100;		// 正确。mutable关键字，在常对象下也可以修改
	
	// 常对象 只能调用 常函数
	p.func();
	// 常对象 不可调用 普通函数，因为 普通函数 可以修改 成员变量
}
```
### 7.4 友元
1. 目的：让 一个函数 或 类，访问 另一个类中的**私有private成员**。
2. 关键字：==`friend`==
3. 友元 的 三种实现：
  - **全局函数** 做 友元
  - **类** 做 友元
  - **成员函数** 做 友元
#### 7.4.1 成员函数 做 友元
1. 方法：在 类中  *最开始* 声明 全局函数：**`friend 全局函数名(形参);`**
2. 比如：
```c
class Building
{
    /*      声明 全局函数 并且 为 友元 */
    // GoodFriend函数 为 Building中的 尤元，可以访问 类中 私有属性
    friend void GoodFriend(Building *build);        
private:
    std::string m_SittingRoom;      // 客厅
public:
    // 构造函数
    Building(){
        m_BedRoom = "bed room";
    }
};
/*      定义 全局函数    */
// 传入的 形参 为 Building类（引用形式 或者 指针形式） 为 build 本身
void GoodFriend(Building *build){            
    // 因为 build为指针，所以使用->取成员
    // 因为 友元 所以 可以访问 private 成员
    std::cout << build -> m_SittingRoom << std::endl;
}
```
#### 7.4.2 类 做 友元
1. 方法：在 A类中 *最开始* 声明 B类：**`friend class 友元类;`**
2. 目的：让 B类 可以访问 A类 的 private内的成员属性
3. 比如：
```c
class Building
{
    /*   GoodGay 类 是 友元，可以 访问 Building中的 Private类 成员   */
    friend class GoodGay;
private:
    /* data */
    std::string m_bedroom;
public:
    Building(/* args */);
    std::string m_livingroom;
};
class GoodGay
{
private:
    /* data */
public:
    GoodGay();
    void visit();                   //  参观函数 访问 Building中的 属性
    Building *building;             // 创建 指针，用于 指向 堆区中的 对象
};
/*   类外 写 构造函数 与 析构函数   */
Building::Building(/* args */)
{
    m_livingroom = "living room";
    m_bedroom = "bed room";
}
GoodGay::GoodGay(){
    // 创建一个 building对象
    // 在 堆区 创建一个Building对象（返回的是 指针），并且 让 Building* building指针 指向 堆区新创建的 对象
    building = new Building;           
}
/* 类外 声明 成员函数	*/
void GoodGay::visit(){ 
    std::cout << "GoodGay类 正在访问：" << building -> m_livingroom << std::endl;
    // 访问 私有 成员属性
    std::cout << "GoodGay类 正在访问：" << building -> m_bedroom << std::endl;	
}
```
#### 7.4.3 成员函数 做 友元
1. 方法：在 A类中  *最开始* 声明 B类的成员函数：**`friend B类名::函数名(形参);`**
2. 目的：让 B类的成员函数 可以访问 A类 的 private内的成员属性
3. 例如：
```c
class Building
{
    // 声明 友元 成员函数
    // 告诉 编译器 Gooday类 下的 成员函数visit 为 友元函数，可以访问 如下的 私有属性
    friend void GoodGay::visit();   /*	重点	*/
private:
    std::string m_bedroom;
public:
    Building(/* args */);
    std::string m_livingroom;
};
class GoodGay
{
public:
    GoodGay(/* args */);
    Building *building;
    void visit();                   // 想让 visit 成员函数 可以访问 Building 中的 私有成员
};
Building::Building(/* args */)
{
    m_livingroom = "客厅";
    m_bedroom = "卧室";
}
GoodGay::GoodGay(/* args */)
{
    building = new Building;            // 用 指针 维护 在堆区中创建的 对象
}
// 友元 函数
void GoodGay::visit(){
    std::cout << "visit 函数 正在访问：" << building -> m_livingroom << std::endl;
}
int main(){
    // 实例化 对象
    GoodGay gg;
    gg.visit();
    return 0;
}
```
### 7.5 运算符重载
1. 概念：对 ==已有的运算符 **重新进行定义**==，赋予其 另一种功能，用来适应**不同的数据类型**。
2. 为什么使用 运算符重载：对于 **自定义的数据类型**，编译器不知道如何运算
3. 注意事项：
  - 注意1：对于 **内置的数据类型** 的表达式 的 运算符 是**不可以更改的**
  - 注意2：**不要滥用 运算符重载**
#### 7.5.1 加号运算符（operator+） 重载
1. 作用：实现==两个**自定义 数据类型 相加**的运算==
2. 方法：
- 通过**成员函数**重载+号：
  - 重载：在 类 中，创建成员函数：`类名 operator+(类名 &p){	运算	}`
  - 使用：在 程序中，使用`+`号：`类1 + 类2`
  - 本质： `Person p3 = p1.operator+(p2)`
```c
class Person
{
public:
    Person(){
        num = 0;
    }
    int num;
    // 通过成员函数 重载+号
    Person operator+(const Person &p){
         Person temp;	// 用于 返回类属性
         // this 指向 使用该成员函数的 对象
         temp.num = this->num + p.num;       
         return temp;                         // 别忘了 返回值 
    }
};
int main(){
	Person p1;
	p1.num = 10;
	Person p2;
	p2.num = 10;
	// 调用 成员函数 重载	使用 + 号
	Person p3 = p1 + p2;		// p3.num = 20
	return 0;
}
```
- 通过**全局函数**重载+号：
  -  重載：在类外，创建全局函数：`类名 operator+(类名 &p1.类名 &p2)`
  -  使用：在 程序中，使用`+`号：`类1 + 类2`
  -  本质：`Person p3 = operator+(p1,p2)`
```c
/*      函数 重载 的 版本   */
/*  2. 全局函数 重载 + 号*/
Person operator+(Person &p1,Person &p2){
    Person temp;	// 用于 返回类属性
    temp.num = p1.num + p2.num;
    return temp;
}
int main(){
	Person p1;
	p1.num = 10;
	Person p2;
	p2.num = 10;
	// 调用 成员函数 重载	使用 + 号
	Person p3 = p1 + p2;		// p3.num = 20
	return 0;
}
```
3. 注意：运算符 重载 也可以发生 **函数重载**：
例如：
```c
/*      函数 重载 的 版本   */
Person operator+(Person &p,int a){
    Person temp;
    temp.num = p.num + a;
}
int main(){
	Person p1;
	Person p4 = p1 + 30;
}
```
#### 7.5.2 左移运算符（operator<<） 重载 【难点，不会】
1. 作用：可以==**输出自定义**的数据类型==
  - 比如：直接输出 类对象：`cout << 类对象 << endl`，不重载会报错
2. 注意：**不能使用 成员函数** 重载 左移运算符
3. 方法：使用**全局函数**重载 左移运算符
程序：
```c
/*      内容：全局函数 重载 左移 运算符  
        本质：operator<<(cout,p)
        简化：cout << p
*/
// cout 为 ostream输出流类 对象，且 只能有一个 使用引用&【输出流 不能 拷贝】
// 返回值 为 cout ，也为 输出流类型 ostream &(使用 引用，唯一)
// 注意：ostream 输出流类 在 std命名空间下
std::ostream &operator<<(std::ostream &out,Person &p){           
    out << "num = " << p.num << " private_num = " << p.private_num;
    return out;
}
```
4. 总结：重载左翼运算符**配合 友元** 可以实现 **输出自定义类型**
```c
class Person
{
    // 友元 全局函数
    friend std::ostream &operator<<(std::ostream &out,Person &p);

private:
    /* data */
    int private_num;
public:
    Person(int a){
    	private_num = a;
    };
    int num;
    /*      注意：不能 利用 成员函数 重载 << 运算符  
            因为：无法 实现 cout在左侧
            所以：只能 利用 全局函数 重载 << 运算符
    */ 
};
int main(){
	Person p(100);
    p.num = 10;
    /*		直接 输出 类对象p 便可以 输出内容 */
    std::cout << p << std::endl;
    return 0;
}

```
#### 7.5.3 递增运算符（operator++） 重载
1. 作用：通过 重载递增运算符，==实现自己的**整型数据**==
##### 递增运算符：【重点】
1. 前置递增`++a`：==**先进行 变量 递增**，再 输出 表达式==
```c
	int a = 10;
	cout << ++a << endl;	// a = 11，先递增 a，再输出 a
	cout << a << ednl;		// a = 11。a 已经 递增过一次
```
2. 后置递增`b++`：==**先进行 表达式运算**，再 变量 递增==
```c
	int b = 10;
	cout << b++ << endl;	// b = 10，先输出 b，再进行b+1递增
	cout << b << end;		// b = 11
```
##### 重载 前置递增【前置 返回 引用】
1. 位置：在 类 内，为 成员函数
2. 重点：返回类型 为 **`类名 &`**
程序：
```c
/** 重载 前置递增
      * 目的：使 m_Num++ 
      * 返回类型：MyInteger&
    */
    // 【前置 返回 引用】。原因：为了 一直对一个数据 进行递增操作
    MyInteger& operator++(){
        // 先进行++运算
        m_Num++;
        // 再 进行返回
        return *this;       // 返回 自身类 类型：自身为this，解引用*this为 自身的值。返回值 为：MyInteger& ，把自身作为一个返回
    }
```
2. 注意：
```c
	 // 若返回的不是引用&,则
    std::cout << ++(++myint) << std::endl;  // 输出 为 2
    std::cout << myint << std::endl;        // 输出 则为 1（没有传递给 myint对象）
```
##### 重载 后置递增【后置 返回 值】
1. 位置：在 类 内，为 成员函数
2. 重点：返回类型 为 **`类名`**
3. 程序：
```c
// 重载 后置递增 【后置 返回 值】原因：temp为临时变量，执行完就 释放掉了，若再返回引用，则非法操作
    MyInteger operator++(int){   // int 代表 占位参数，用于 区分 前置与后置递增。【重点：int！！！】
        // 先 返回 结果（先 记录下 当时的结果）
        MyInteger temp = *this;             // *this 为 自身现在的结果
        // 再 递增
        m_Num++;
        // 最后 将 记录的结果，做为返回
        return temp;
    }
```
#### 7.5.4 赋值运算符 重载
1. C++编译器 至少给 一个类 添加4个函数：
  1. 默认构造函数（无参，函数体为 空）
  2. 默认析构函数（无参，函数体为 空）
  3. 默认拷贝构造函数，对 **属性 进行 值拷贝**
  4. ==赋值运算符`operator=`，对 **属性 进行 值拷贝**==
2. 注意：如果类中 有属性指向 堆区，做 赋值操作时 也会出现 深浅拷贝的问题。
##### 问题
1. 问题：若有析构函数，使用默认的赋值运算符时，系统会因为**内存重复释放**导致程序崩溃。
```c
class Person
{
public:
    Person(int age);
    ~Person();
    int *m_Age;     // 待 开辟到 堆区
    }
};
// 构造函数 时：将 数据 开辟到 堆区
Person::Person(int age)
{
    m_Age = new int(age);                   // 用 m_age 来 维护/管理 堆区age数据
}
// 析构函数：释放 堆区 的数据
Person::~Person(){
    if(m_Age != NULL){
        delete m_Age;                       // 释放 内存
        m_Age = NULL;
    }
}
void test01(){
    Person p1(18);
    Person p2(20);
 	// 错误：堆区内存重复释放，程序崩溃。（因为：p2与p1 都指向 一块 堆区 内存）
    p2 = p1;                           
    std::cout << *p1.m_Age << "  " << *p2.m_Age << std::endl;
}
```
4. 解决方法：利用**重载赋值运算（深拷贝）**，解决 浅拷贝 带来的 问题。
  - 需要在 堆区 重新开辟出 新的 地方，用于 赋值
##### 解决：重载 赋值运算符（operator=）
1. 属性：==**成员函数**==
2. 步骤：
	1. 先 **判断 该对象 是否有 属性 在堆区**：
	2. 如果有：则 **将 自身属性 释放 干净**。
	3. 释放后：再 进行 **深拷贝**（new一块新的空间，进行拷贝）
3. 代码：
```c
class Person
{
public:
    Person(int age);
    ~Person();
    int *m_Age;     // 待 开辟到 堆区
    // 重载 赋值运算符
    Person& operator=(Person &p){       // 返回引用，才是 真的 自身
        // 编译器 提供的 前拷贝：m_age = p.m_age
// 应该 先判断 该对象 是否 有属性 在堆区：如果有 则 先释放干净，然后 再进行 深拷贝
        // 步骤1：判断 是否有属性
        if(m_Age != NULL){
        // 步骤2：先将 自身 属性 释放干净
            delete m_Age;               
            m_Age = NULL;
        }
        // 步骤3：深拷贝操作
        m_Age =  new int(*p.m_Age);     // 在堆区 开辟出 新的 空间，并用 自身 去 管理它
        // 步骤4：增加 返回值，为了 链式 连接
        return *this;                   // 返回 对象的本身： 指向自身的指针 为 this，找回自身本体 为 *this
    }
};
void test01(){
    Person p1(18);
    Person p2(20);
    Person p3(30);
    p3 =p2 = p1;                            // 会使：堆区内存重复释放，程序崩溃。（因为：p2与p1 都指向 一块 堆区 内存）
    std::cout << *p1.m_Age << "  " << *p2.m_Age << "  " << *p3.m_Age << std::endl;
}
```
#### 7.5.5 关系运算符 重载
1. 关系运算符：>，<，!=，==
2. 重载的作用：重载 关系运算符，可以让 两个 **自定义类型的 对象** 进行 **对比**操作
##### 重载 ==运算符（operator==）
1. 重点：**在 类 内**定义
2. 程序：
```c
class Person
{
public:
/*      重载 == 关系运算符     */
    bool operator==(const Person &p){
        if(this->m_age == p.m_age)
            return true;
        else
            return false;
    }
}
```
##### 重载 !=运算符（operator!=）
1. 重点：**在 类 内**定义
2. 程序：
```c
class Person
{
public:
/*      重载 ！= 关系运算符     */
    bool operator!=(const Person &p){
        if(this->m_age == p.m_age)
            return false;
        else
            return true;
    }
}
```
#### 7.5.6 函数调用运算符（operator()） 重载【也称 仿函数】
1. 位置：**在 类 内**定义
2. 定义：函数调用运算符 **( )** 也可以 重载
3. 概念：由于 重载后 使用的方式 非常像 函数的调用，因此称为 **仿函数**
4. 注意：仿函数**没有固定写法**，非常灵活【==依照 **不同需求** ，写 **不同 的 仿函数**==】
5. 比如：
```c
class MyPrint
{
public:
/*      重载 函数调用运算符     */
    void operator()(std::string test){
        std::cout << test << std::endl;
    }
}

int main(){
    MyPrint myprint;
    myprint("helloworld");      // 由于 使用起来 非常像 函数调用，因此称为 仿函数
    
    return 0;
}
```
##### 技巧：使用 匿名对象
1. 创建 匿名对象：`类名()`
2. 特点：使用完后，就 销毁
3. 作用：可以**不用 创建 类对象**，即可 使用 仿函数
例如：
```c
// 加法类
class MyAdd
{
public:
	// 仿函数
    int operator()(int num1,int num2){
        return num1+num2;
    }
};
int main(){
	// 使用 匿名函数对象
	cout << MyAdd()(10,20) << endl;			// 30
	return 0;
}
```

# C++核心编程
## 一、面向对象（OPP）
### 1. 内存分区模型
1. 四个区域：程序执行时，将内存分成4个区域
- ==代码区==【运行前有】：存放所有代码的区域（二进制代码），由操作系统进行管理
  - 存放CPU执行的机器指令
  - 代码区 是 **共享**的，共享的目的是 频繁被执行的程序，内存中只有一份代码即可
  - 代码区是**只读**的，只读的目的是 防止程序意外地修改其命令

- ==全局区==【运行前有】：存放 全局变量 、 静态变量 和 常量
  - 存放 全局变量（主函数外定义的）和 静态变量（static）
  - 包含了 常量区：存放 字符串常量和 全局常量【局部常量 不在全局区内】
  - 该区域的数据在程序结束后，由==操作系统释放==

- ==栈区==【运行后有】：由 编译器自动分配和释放
  - 为 ==函数区==
  - 存放 函数的形参，局部变量等
  - 注意事项：**不要返回局部变量的地址**，栈区开辟的数据由编译器自动释放
```c
int* func(){
	int a = 10;		// 局部变量
	return &a;		// 返回局部变量地址，会带来不可预知的错误后果
}
```

- ==堆区==【运行后划分】：由 程序员 分配和释放，若程序员不释放，结束时由系统回收
  - 在C++中，主要利用**new**在堆区开辟内存
```c
int * func(){
	// 利用 new关键字 可以将数据开辟到 堆区.[new 传递的是 数据的地址 ]
	// 其中，必须用 指针来定义【指针 保存在 栈上】
	int *p = new int(10);	// 10为int的初始值.【指针保存的数据 放在堆区】
	//在堆区开辟一段内存，并用指针p返回内存的编号
	return p;		// 返回的是 10所在的地址。不是p的地址（&p）
}

int main(){
	// 在堆区开辟数据
	int *p = func();
}
```
2. 意义：不同区域存放的数据，赋予**不同的生命周期**，灵活编程
### 2. new 操作符
1. 语法：`new 数据类型`
2. 利用 new在堆区开辟数据
3. 释放数据：用 `delete`。堆区的数据 由程序员管理开辟，管理释放
4. **接收的是**：==数据 或者 指针内的内容（\*p）== 
5. **返回的是**：new 操作符 返回的是 == 数据类型 的 **指针**类型==
```c
// 1. new 的基本语法
int * func(){
	// 在堆区 创建 整型数据
	// new 返回的是 该数据类型的 指针，需要 p为 指针类型
	int *p = new int(10);		// 存放了数据 10. 
	return p;					// 返回的是 数据10的地址
}
// 2. 释放 堆区数据：利用关键字 delete
void test(){
	int *p = func();
	cout << *p << endl;		// 释放前 打印p
	// delete释放 堆区的数据
	delete p;
	
	cout<< *p << endl;		// 释放后 打印堆区 就是非法操作
}
```
4. 在 堆区 用new开辟==数组==。用`delete[] 变量`来释放 堆区的数组
```c
void test02(){
	// 创建整型数据的数组，用[]创建；用[]来使用
	int *arr = new int[10];		// 10 代表 数组有10个元素。返回的还是首地址

	for(int i=0;i<10;i++){
		arr[i] = i+100;			// 给10个元素赋值 100～109
	}
	
	// 释放 堆区数组
	// 释放 数组的时候，要加[]才可以。【用 delete[]】
	delete[] arr;
}
```
5. 


# C++常用函数
### 生成随机数：
```c
/*	time时间系统 头文件	*/
#include<ctime>				// 头文件

int main{
/* 添加 随机数种子：利用当前时间生成随机数，防止每次随机数都一样 */
	srand( (unsigned int)time(NULL) );
	
	rand()%100;		// 生成 0~99的随机数
}
```
### 查看内存空间：
```c
	sizeof(变量)	：查看 变量 所占的内存空间
```
### 推断 变量的类型：【auot 或 decltype】
```c
	auto len = s.size();		// 系统自己定义 len的类型 （是 string::size_type类型） 
```

# C++头文件的使用
## 对 String对象 中字符的操作【注意：是 字符对象】
### cctype头文件
```c
#include<cctype>
	// 头文件中的函数
	isalnum(c);					// 若 s为 字母或数字 时，为真，否则为假
	isalpha(c);					// 若 s为 字母 时，为真，否则为假
	iscntrl(c);					// 若 s为 控制字符 时，为真，否则为假
	isdigit(c);					// 若 s为 数字 时，为真，否则为假
	isgraph(c);					// 若 s为 不是空格但可打印 时，为真，否则为假
	islower(c);					// 若 s为 小写字母 时，为真，否则为假
	isprint(c);					// 若 s为 可打印字符（如：空格） 时，为真，否则为假
	ispunct(c);					// 若 s为 标点符号 时，为真，否则为假
	isspace(c);					// 若 s为 空白（空格、制表符、回车、换行等） 时，为真，否则为假
	isupper(c);					// 若 s为 大写字母 时，为真，否则为假
	isxdigit(c);				// 若 s为 十六进制数字 时，为真，否则为假

	tolower(c); 				// 若 s为大写字母，则输出 对应的小写字母
	toupper(c); 				// 若 s为小写字母，则输出 对应的大写字母
```

# C++ 命名空间
1. 主要作用：**防止 命名冲突**，不同库中的同名标识符可以共存。
2. 使用方法：
  - 方法一：显示使用（如：std：：）【优先使用】
  - 方法二：使用 using 声明
  - 方法三：使用 全局声明 using namespace std【谨慎使用】

## 一、标准命名空间（std）
### 1. 包含的内容、标识符：
- 输入输出流：`cin`,`cout`,`cerr`
- 容器：`vector`, `map`,`set`）
- 算法：`sort()`, `find()`
- 字符串：`std::string`
- 智能指针：`shared_ptr`, `unique_ptr`
- 文件流：`fstream`
- 以及其他数百个标准组件

# 习题:
## 没做完:
### 6.2.3